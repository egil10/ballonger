<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bloons Tower Defense MVP</title>
    <link rel="icon" type="image/svg+xml" href="logo.svg">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 15px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: auto;
            color: #333;
        }
        
        #gameContainer {
            display: flex;
            background: linear-gradient(145deg, #2c3e50, #34495e);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3), 0 0 0 1px rgba(255,255,255,0.1);
            max-width: 95vw;
            max-height: 95vh;
            align-items: stretch;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            border-radius: 20px 0 0 20px;
        }
        
        #ui {
            width: 320px;
            background: linear-gradient(180deg, #27ae60 0%, #2ecc71 100%);
            padding: 25px;
            border-radius: 0 20px 20px 0;
            color: white;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.1);
        }
        
        .logo {
            text-align: center;
            margin-bottom: 10px;
            font-size: 28px;
            font-weight: 800;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            letter-spacing: 2px;
        }
        
        .stats-container {
            background: rgba(255,255,255,0.15);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .stat {
            margin-bottom: 12px;
            font-size: 16px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .stat-value {
            background: rgba(255,255,255,0.2);
            padding: 5px 12px;
            border-radius: 20px;
            font-weight: 700;
            min-width: 60px;
            text-align: center;
        }
        
        .game-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .game-btn {
            width: 100%;
            padding: 15px 20px;
            background: linear-gradient(145deg, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 700;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        .game-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        .game-btn:hover::before {
            left: 100%;
        }
        
        .game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }
        
        .game-btn:active {
            transform: translateY(0);
        }
        
        .game-btn:disabled {
            background: linear-gradient(145deg, #95a5a6, #7f8c8d);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .game-btn:disabled::before {
            display: none;
        }
        
        .section-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 15px;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
            position: relative;
        }
        
        .section-title::after {
            content: '';
            position: absolute;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 3px;
            background: rgba(255,255,255,0.5);
            border-radius: 2px;
        }
        
        .tower-selection {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .tower-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .tower-option {
            width: 50px;
            height: 50px;
            background: linear-gradient(145deg, #8B4513, #A0522D);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        
        .tower-option:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 15px rgba(0,0,0,0.3);
        }
        
        .tower-option.selected {
            border-color: #f39c12;
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.6);
            transform: scale(1.05);
        }
        
        .tower-option.cost {
            background: linear-gradient(145deg, #e74c3c, #c0392b);
        }
        
        .tower-option.ice {
            background: linear-gradient(145deg, #87CEEB, #5DADE2);
        }
        
        .tower-option.fire {
            background: linear-gradient(145deg, #FF69B4, #E91E63);
        }
        
        .tower-option.bomb {
            background: linear-gradient(145deg, #000, #2C3E50);
        }
        
        .tower-option.super {
            background: linear-gradient(145deg, #4169E1, #1E3A8A);
        }
        
        .upgrades-section {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .upgrade-btn {
            width: 100%;
            padding: 12px 16px;
            margin: 8px 0;
            background: linear-gradient(145deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 10px rgba(231, 76, 60, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        .upgrade-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        .upgrade-btn:hover::before {
            left: 100%;
        }
        
        .upgrade-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(231, 76, 60, 0.4);
        }
        
        .upgrade-btn:active {
            transform: translateY(0);
        }
        
        .upgrade-btn:disabled {
            background: linear-gradient(145deg, #95a5a6, #7f8c8d);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .upgrade-btn:disabled::before {
            display: none;
        }
        
        .tower-info {
            background: rgba(255,255,255,0.15);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(10px);
        }
        
        .tower-info h4 {
            margin: 0 0 15px 0;
            font-size: 16px;
            font-weight: 700;
            text-align: center;
        }
        
        .tower-stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .tower-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
        }
        
        .tower-stat.upgraded {
            background: rgba(243, 156, 18, 0.3);
            border: 1px solid rgba(243, 156, 18, 0.5);
        }
        
        .speed-section {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .speed-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .speed-slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .speed-slider {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: rgba(255,255,255,0.3);
            outline: none;
            -webkit-appearance: none;
        }
        
        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #f39c12;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }
        
        .speed-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
        }
        
        .speed-display {
            background: rgba(255,255,255,0.2);
            padding: 8px 12px;
            border-radius: 20px;
            font-weight: 700;
            min-width: 50px;
            text-align: center;
            font-size: 14px;
        }
        
        .speed-buttons {
            display: flex;
            gap: 8px;
        }
        
        .speed-btn {
            flex: 1;
            padding: 10px 8px;
            background: linear-gradient(145deg, #95a5a6, #7f8c8d);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .speed-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        
        .speed-btn.active {
            background: linear-gradient(145deg, #e74c3c, #c0392b);
            box-shadow: 0 4px 10px rgba(231, 76, 60, 0.4);
        }
        
        .restart-section {
            text-align: center;
        }
        
        .restart-btn {
            width: 100%;
            padding: 15px 20px;
            background: linear-gradient(145deg, #9b59b6, #8e44ad);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 700;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(155, 89, 182, 0.3);
        }
        
        .restart-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(155, 89, 182, 0.4);
        }
        
        .restart-btn:active {
            transform: translateY(0);
        }
        
        /* Scrollbar styling */
        #ui::-webkit-scrollbar {
            width: 8px;
        }
        
        #ui::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
        }
        
        #ui::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 4px;
        }
        
        #ui::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.5);
        }
        
        /* Responsive design */
        @media (max-width: 1200px) {
            #ui {
                width: 280px;
                padding: 20px;
            }
            
            .tower-option {
                width: 45px;
                height: 45px;
                font-size: 16px;
            }
        }
        
        @media (max-width: 900px) {
            #gameContainer {
                flex-direction: column;
                max-height: 95vh;
            }
            
            canvas {
                border-radius: 20px 20px 0 0;
            }
            
            #ui {
                width: 100%;
                border-radius: 0 0 20px 20px;
                max-height: 40vh;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="sketch-holder"></div>
        <div id="ui">
            <div class="logo">egil games</div>
            
            <div class="stats-container">
                <div class="stat">Round: <span class="stat-value" id="round">0</span>/40</div>
                <div class="stat">Money: <span class="stat-value">$<span id="money">650</span></span></div>
                <div class="stat">Lives: <span class="stat-value" id="lives">40</span></div>
            </div>
            
            <div class="game-controls">
                <button class="game-btn" id="startBtn">Start Game</button>
                <button class="game-btn" id="nextRoundBtn" disabled>Next Round</button>
            </div>
            
            <div class="tower-selection">
                <div class="section-title">Build Towers ($100)</div>
                <div class="tower-grid">
                    <div class="tower-option cost" data-tower="monkey">M</div>
                    <div class="tower-option ice" data-tower="ice">I</div>
                    <div class="tower-option fire" data-tower="fire">F</div>
                    <div class="tower-option bomb" data-tower="bomb">B</div>
                    <div class="tower-option super" data-tower="super">S</div>
                </div>
                <div style="text-align: center; font-size: 12px; opacity: 0.8;">
                    Click to select tower type
                </div>
            </div>
            
            <div class="upgrades-section">
                <div class="section-title">Upgrades</div>
                <button class="upgrade-btn" id="rangeUpgrade">Upgrade Range ($50)</button>
                <button class="upgrade-btn" id="pierceUpgrade">Upgrade Pierce ($50)</button>
            </div>
            
            <div class="tower-info">
                <h4>Selected Tower</h4>
                <div class="tower-stats" id="selectedTowerInfo">
                    <div style="text-align: center; opacity: 0.7;">Click a tower to select</div>
                </div>
            </div>
            
            <div class="speed-section">
                <div class="section-title">Game Speed</div>
                <div class="speed-controls">
                    <div class="speed-slider-container">
                        <label for="speedSlider" style="font-size: 14px; font-weight: 600;">Speed:</label>
                        <input type="range" class="speed-slider" id="speedSlider" min="1" max="10" value="1">
                        <span class="speed-display" id="speedDisplay">1x</span>
                    </div>
                    <div class="speed-buttons">
                        <button class="speed-btn active" data-speed="1">1x</button>
                        <button class="speed-btn" data-speed="2">2x</button>
                        <button class="speed-btn" data-speed="5">5x</button>
                        <button class="speed-btn" data-speed="10">10x</button>
                    </div>
                </div>
            </div>
            
            <div class="restart-section">
                <button class="restart-btn" id="restartBtn">Restart Game</button>
            </div>
        </div>
    </div>

    <script>
        // Game constants
        const GRID_SIZE = 30; // Larger grid size for 20x20
        const COLS = 20;
        const ROWS = 20;
        const CANVAS_WIDTH = COLS * GRID_SIZE;
        const CANVAS_HEIGHT = ROWS * GRID_SIZE;
        const TOWER_PLACEMENT_RADIUS = 80; // Adjusted for larger grid

        // Game state
        let gameState = {
            money: 650,
            lives: 40,
            round: 0,
            maxRounds: 40,
            balloons: [],
            towers: [],
            projectiles: [],
            waveInProgress: false,
            balloonsInWave: 0,
            balloonsSpawned: 0,
            spawnTimer: 0,
            spawnInterval: 30,
            gameOver: false,
            gameWon: false,
            gameStarted: false,
            selectedTower: null,
            gameSpeed: 1,
            selectedTowerType: 'monkey' // Default tower type
        };

        // Base tower configuration
        let baseTowerConfig = {
            range: 120,
            pierce: 1,
            damage: 1,
            fireRate: 60,
            cost: 100
        };

        // Balloon colors and sizes by tier
        const BALLOON_COLORS = {
            1: [255, 0, 0],    // Red
            2: [0, 0, 255],    // Blue
            3: [0, 255, 0],    // Green
            4: [255, 255, 0],  // Yellow
            5: [0, 0, 0],      // Black
            6: [255, 255, 255] // White
        };
        
        const BALLOON_SIZES = {
            1: 0.8,    // Red - normal
            2: 0.9,    // Blue - larger
            3: 1.0,    // Green - larger
            4: 1.1,    // Yellow - larger
            5: 0.6,    // Black - smaller
            6: 0.5     // White - smaller than black
        };

        // Grid definition (0=empty, 1=path, 2=start, 3=end)
        const GRID_DATA = [
            [0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0],
            [0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0],
            [0,0,0,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,0,0],
            [2,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,1,0,0,0,1,1,1,1,1,1,1,0,0],
            [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0],
            [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0],
            [0,0,0,0,0,0,0,1,0,0,0,1,1,1,1,1,1,1,0,0],
            [0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,1,0,0,0,1,1,1,1,1,1,1,0,0],
            [0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0],
            [0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],
            [0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],
            [0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],
            [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
        ];

        // Convert grid to path array
        function generatePathFromGrid() {
            let path = [];
            let start = null;
            let end = null;
            
            // Find start and end points
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (GRID_DATA[y][x] === 2) {
                        start = {x: x + 1, y: y + 1};
                    } else if (GRID_DATA[y][x] === 3) {
                        end = {x: x + 1, y: y + 1};
                    }
                }
            }
            
            // Use A* pathfinding to find the path from start to end
            path = findPath(start, end);
            return path;
        }

        // Simple pathfinding to connect start to end through path cells
        function findPath(start, end) {
            let path = [start];
            let current = start;
            
            // Simple greedy pathfinding - move towards end through path cells
            while (current.x !== end.x || current.y !== end.y) {
                let next = findNextStep(current, end);
                if (next) {
                    path.push(next);
                    current = next;
                } else {
                    break; // Can't find path
                }
            }
            
            return path;
        }

        function findNextStep(current, end) {
            let directions = [
                {dx: 1, dy: 0}, {dx: -1, dy: 0}, {dx: 0, dy: 1}, {dx: 0, dy: -1},
                {dx: 1, dy: 1}, {dx: -1, dy: 1}, {dx: 1, dy: -1}, {dx: -1, dy: -1}
            ];
            
            for (let dir of directions) {
                let nextX = current.x + dir.dx;
                let nextY = current.y + dir.dy;
                
                // Check bounds
                if (nextX < 1 || nextX > COLS || nextY < 1 || nextY > ROWS) continue;
                
                // Check if it's a path cell (1) or end cell (3)
                if (GRID_DATA[nextY - 1][nextX - 1] === 1 || GRID_DATA[nextY - 1][nextX - 1] === 3) {
                    // Check if this step gets us closer to end
                    let currentDist = Math.abs(current.x - end.x) + Math.abs(current.y - end.y);
                    let nextDist = Math.abs(nextX - end.x) + Math.abs(nextY - end.y);
                    
                    if (nextDist <= currentDist) {
                        return {x: nextX, y: nextY};
                    }
                }
            }
            
            return null;
        }

        // Generate the path
        const PATH = generatePathFromGrid();

        function setup() {
            let canvas = createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);
            canvas.parent('sketch-holder');
            
            // Set up event listeners
            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('nextRoundBtn').addEventListener('click', startNextRound);
            document.getElementById('rangeUpgrade').addEventListener('click', upgradeRange);
            document.getElementById('pierceUpgrade').addEventListener('click', upgradePierce);
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            
            // Speed control event listeners
            document.getElementById('speedSlider').addEventListener('input', updateSpeedFromSlider);
            document.querySelectorAll('.speed-btn').forEach(btn => {
                btn.addEventListener('click', () => setSpeed(parseInt(btn.dataset.speed)));
            });
            
            // Tower selection event listeners
            document.querySelectorAll('.tower-option').forEach(option => {
                option.addEventListener('click', () => selectTowerType(option.dataset.tower));
            });
            
            // Set default tower type as selected
            selectTowerType('monkey');
            
            updateUI();
        }

        function draw() {
            if (gameState.gameOver) {
                drawGameOver();
                return;
            }
            
            if (gameState.gameWon) {
                drawGameWon();
                return;
            }
            
            drawBackground();
            drawPath();
            updateAndDrawBalloons();
            updateAndDrawTowers();
            updateAndDrawProjectiles();
            updateWave();
            updateUI();
        }

        function drawBackground() {
            // Draw grass background
            fill(34, 139, 34);
            rect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Draw grid lines
            stroke(0, 100, 0);
            strokeWeight(1);
            for (let i = 0; i <= COLS; i++) {
                line(i * GRID_SIZE, 0, i * GRID_SIZE, CANVAS_HEIGHT);
            }
            for (let j = 0; j <= ROWS; j++) {
                line(0, j * GRID_SIZE, CANVAS_WIDTH, j * GRID_SIZE);
            }
            noStroke();
        }

        function drawPath() {
            // Draw path based on grid data
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    let cellValue = GRID_DATA[y][x];
                    if (cellValue === 1) {
                        // Path cell
                        fill(139, 69, 19);
                        rect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                    } else if (cellValue === 2) {
                        // Start cell (blue)
                        fill(0, 0, 255);
                        rect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                    } else if (cellValue === 3) {
                        // End cell (red)
                        fill(255, 0, 0);
                        rect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                    }
                }
            }
        }

        function startGame() {
            gameState.gameStarted = true;
            gameState.round = 1;
            document.getElementById('startBtn').disabled = true;
            startWave();
        }

        function startNextRound() {
            gameState.round++;
            document.getElementById('nextRoundBtn').disabled = true;
            startWave();
        }

        function startWave() {
            gameState.waveInProgress = true;
            
            // Progressive difficulty: more balloons and varied timing
            let baseBalloons = 8;
            let roundMultiplier = 1 + (gameState.round - 1) * 0.3;
            gameState.balloonsInWave = Math.floor(baseBalloons * roundMultiplier);
            
            // Varied spawn timing based on round with more randomness
            let baseInterval = 30;
            let timingVariation = Math.max(10, baseInterval - (gameState.round - 1) * 2);
            gameState.spawnInterval = timingVariation + Math.floor(Math.random() * 20) - 10; // Add randomness
            
            gameState.balloonsSpawned = 0;
            gameState.spawnTimer = 0;
        }

        function updateWave() {
            if (!gameState.waveInProgress || !gameState.gameStarted) return;
            
            gameState.spawnTimer += gameState.gameSpeed;
            
            // Spawn balloons with varied timing and more randomness
            if (gameState.spawnTimer >= gameState.spawnInterval && gameState.balloonsSpawned < gameState.balloonsInWave) {
                spawnBalloon();
                gameState.balloonsSpawned++;
                gameState.spawnTimer = 0;
                
                // Add more randomness to spawn timing
                let baseInterval = 30;
                let timingVariation = Math.max(10, baseInterval - (gameState.round - 1) * 2);
                gameState.spawnInterval = timingVariation + Math.floor(Math.random() * 30) - 15; // More randomness
            }
            
            // Check if wave is complete
            if (gameState.balloonsSpawned >= gameState.balloonsInWave && gameState.balloons.length === 0) {
                gameState.waveInProgress = false;
                
                if (gameState.round >= gameState.maxRounds) {
                    gameState.gameWon = true;
                } else {
                    document.getElementById('nextRoundBtn').disabled = false;
                }
            }
        }

        function spawnBalloon() {
            // Progressive difficulty: higher tier balloons appear in later rounds
            let maxTier = Math.min(6, Math.floor(gameState.round / 3) + 1);
            let tier = Math.floor(Math.random() * maxTier) + 1;
            let speed = tier === 4 ? 2 : 1; // Yellow balloons are faster
            
            // Increase speed in later rounds
            speed += Math.floor((gameState.round - 1) / 5);
            
            // Add slight position variation to prevent perfect alignment
            let spawnX = PATH[0].x * GRID_SIZE + GRID_SIZE / 2 + (Math.random() * 10 - 5);
            let spawnY = PATH[0].y * GRID_SIZE + GRID_SIZE / 2 + (Math.random() * 10 - 5);
            
            gameState.balloons.push({
                x: spawnX,
                y: spawnY,
                pathIndex: 0,
                tier: tier,
                speed: speed,
                health: 1,
                maxHealth: 1
            });
        }

        function updateAndDrawBalloons() {
            for (let i = gameState.balloons.length - 1; i >= 0; i--) {
                let balloon = gameState.balloons[i];
                
                // Move balloon along path
                if (balloon.pathIndex < PATH.length - 1) {
                    let targetX = PATH[balloon.pathIndex + 1].x * GRID_SIZE + GRID_SIZE / 2;
                    let targetY = PATH[balloon.pathIndex + 1].y * GRID_SIZE + GRID_SIZE / 2;
                    
                    let dx = targetX - balloon.x;
                    let dy = targetY - balloon.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < balloon.speed * gameState.gameSpeed) {
                        balloon.pathIndex++;
                        if (balloon.pathIndex >= PATH.length - 1) {
                            // Balloon reached the end
                            gameState.lives--;
                            gameState.balloons.splice(i, 1);
                            continue;
                        }
                    } else {
                        balloon.x += (dx / distance) * balloon.speed * gameState.gameSpeed;
                        balloon.y += (dy / distance) * balloon.speed * gameState.gameSpeed;
                    }
                }
                
                // Draw balloon with variable size
                let color = BALLOON_COLORS[balloon.tier];
                let size = BALLOON_SIZES[balloon.tier];
                fill(color[0], color[1], color[2]);
                ellipse(balloon.x, balloon.y, GRID_SIZE * size, GRID_SIZE * size);
                
                // Draw health bar for damaged balloons
                if (balloon.health < balloon.maxHealth) {
                    fill(255, 0, 0);
                    rect(balloon.x - GRID_SIZE/2, balloon.y - GRID_SIZE/2 - 10, GRID_SIZE, 5);
                    fill(0, 255, 0);
                    rect(balloon.x - GRID_SIZE/2, balloon.y - GRID_SIZE/2 - 10, 
                         (balloon.health / balloon.maxHealth) * GRID_SIZE, 5);
                }
            }
        }

        function updateAndDrawTowers() {
            for (let tower of gameState.towers) {
                // Draw tower (smaller size)
                if (gameState.selectedTower === tower) {
                    fill(255, 215, 0); // Gold for selected tower
                } else {
                    fill(139, 69, 19);
                }
                rect(tower.x - GRID_SIZE/3, tower.y - GRID_SIZE/3, GRID_SIZE * 2/3, GRID_SIZE * 2/3);
                
                // Draw range indicator (transparent)
                fill(255, 255, 255, 30);
                ellipse(tower.x, tower.y, tower.range * 2, tower.range * 2);
                
                // Update cooldown
                if (tower.cooldown > 0) {
                    tower.cooldown -= gameState.gameSpeed;
                }
                
                // Find target and shoot
                if (tower.cooldown <= 0) {
                    let target = findTarget(tower);
                    if (target) {
                        shoot(tower, target);
                        tower.cooldown = tower.fireRate;
                    }
                }
            }
        }

        function findTarget(tower) {
            let bestTarget = null;
            let bestProgress = -1;
            
            for (let balloon of gameState.balloons) {
                let distance = dist(tower.x, tower.y, balloon.x, balloon.y);
                if (distance <= tower.range) {
                    if (balloon.pathIndex > bestProgress) {
                        bestTarget = balloon;
                        bestProgress = balloon.pathIndex;
                    }
                }
            }
            
            return bestTarget;
        }

        function shoot(tower, target) {
            gameState.projectiles.push({
                x: tower.x,
                y: tower.y,
                targetX: target.x,
                targetY: target.y,
                speed: 5,
                damage: tower.damage,
                pierce: tower.pierce,
                targetsHit: []
            });
        }

        function updateAndDrawProjectiles() {
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                let projectile = gameState.projectiles[i];
                
                // Move projectile
                let dx = projectile.targetX - projectile.x;
                let dy = projectile.targetY - projectile.y;
                let distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < projectile.speed * gameState.gameSpeed) {
                    // Projectile reached target
                    gameState.projectiles.splice(i, 1);
                    continue;
                }
                
                projectile.x += (dx / distance) * projectile.speed * gameState.gameSpeed;
                projectile.y += (dy / distance) * projectile.speed * gameState.gameSpeed;
                
                // Draw projectile
                fill(255, 255, 0);
                ellipse(projectile.x, projectile.y, 8, 8);
                
                // Check for hits
                for (let j = gameState.balloons.length - 1; j >= 0; j--) {
                    let balloon = gameState.balloons[j];
                    
                    if (projectile.targetsHit.includes(balloon)) continue;
                    
                    let hitDistance = dist(projectile.x, projectile.y, balloon.x, balloon.y);
                    if (hitDistance < GRID_SIZE / 2) {
                        balloon.health -= projectile.damage;
                        projectile.targetsHit.push(balloon);
                        
                        if (balloon.health <= 0) {
                            // Balloon popped
                            gameState.money += 5;
                            gameState.balloons.splice(j, 1);
                            
                            // Create child balloons based on tier
                            if (balloon.tier > 1) {
                                let childTier = balloon.tier - 1;
                                let childSpeed = childTier === 4 ? 2 : 1;
                                let childCount = balloon.tier === 5 ? 2 : 1; // Black balloons create 2 children
                                
                                for (let k = 0; k < childCount; k++) {
                                    gameState.balloons.push({
                                        x: balloon.x,
                                        y: balloon.y,
                                        pathIndex: balloon.pathIndex,
                                        tier: childTier,
                                        speed: childSpeed,
                                        health: 1,
                                        maxHealth: 1
                                    });
                                }
                            }
                        }
                        
                        if (projectile.targetsHit.length >= projectile.pierce) {
                            gameState.projectiles.splice(i, 1);
                            break;
                        }
                    }
                }
            }
        }

        function mousePressed() {
            if (mouseX < CANVAS_WIDTH && mouseY < CANVAS_HEIGHT) {
                // Check if clicking on existing tower to select it
                for (let tower of gameState.towers) {
                    let distance = dist(mouseX, mouseY, tower.x, tower.y);
                    if (distance < GRID_SIZE / 2) {
                        gameState.selectedTower = tower;
                        updateSelectedTowerInfo();
                        return;
                    }
                }
                
                // Place new tower at grid position
                let gridX = Math.floor(mouseX / GRID_SIZE);
                let gridY = Math.floor(mouseY / GRID_SIZE);
                
                // Check if position is valid (not on path)
                let onPath = false;
                if (gridY >= 1 && gridY <= ROWS && gridX >= 1 && gridX <= COLS) {
                    let cellValue = GRID_DATA[gridY - 1][gridX - 1];
                    onPath = (cellValue === 1 || cellValue === 2 || cellValue === 3);
                }
                
                if (!onPath) {
                    let towerX = gridX * GRID_SIZE + GRID_SIZE / 2;
                    let towerY = gridY * GRID_SIZE + GRID_SIZE / 2;
                    
                                    // Check minimum distance from other towers
                let tooClose = false;
                for (let tower of gameState.towers) {
                    let distance = dist(towerX, towerY, tower.x, tower.y);
                    if (distance < TOWER_PLACEMENT_RADIUS) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose && gameState.money >= baseTowerConfig.cost) {
                    let newTower = {
                        x: towerX,
                        y: towerY,
                        range: baseTowerConfig.range,
                        pierce: baseTowerConfig.pierce,
                        damage: baseTowerConfig.damage,
                        fireRate: baseTowerConfig.fireRate,
                        cooldown: 0,
                        rangeUpgraded: false,
                        pierceUpgraded: false
                    };
                    
                    gameState.money -= baseTowerConfig.cost;
                    gameState.towers.push(newTower);
                    gameState.selectedTower = newTower;
                    updateSelectedTowerInfo();
                }
                }
            }
        }

        function upgradeRange() {
            if (gameState.selectedTower && !gameState.selectedTower.rangeUpgraded && gameState.money >= 50) {
                gameState.money -= 50;
                gameState.selectedTower.range += 20;
                gameState.selectedTower.rangeUpgraded = true;
                updateSelectedTowerInfo();
            }
        }

        function upgradePierce() {
            if (gameState.selectedTower && !gameState.selectedTower.pierceUpgraded && gameState.money >= 50) {
                gameState.money -= 50;
                gameState.selectedTower.pierce += 1;
                gameState.selectedTower.pierceUpgraded = true;
                updateSelectedTowerInfo();
            }
        }

        function selectTowerType(towerType) {
            gameState.selectedTowerType = towerType;
            
            // Update visual selection
            document.querySelectorAll('.tower-option').forEach(option => {
                option.classList.remove('selected');
            });
            document.querySelector(`[data-tower="${towerType}"]`).classList.add('selected');
        }

        function updateSelectedTowerInfo() {
            let infoDiv = document.getElementById('selectedTowerInfo');
            if (gameState.selectedTower) {
                let tower = gameState.selectedTower;
                infoDiv.innerHTML = `
                    <div class="tower-stat ${tower.rangeUpgraded ? 'upgraded' : ''}">
                        <span>Range</span>
                        <span>${tower.range} ${tower.rangeUpgraded ? '✓' : ''}</span>
                    </div>
                    <div class="tower-stat ${tower.pierceUpgraded ? 'upgraded' : ''}">
                        <span>Pierce</span>
                        <span>${tower.pierce} ${tower.pierceUpgraded ? '✓' : ''}</span>
                    </div>
                    <div class="tower-stat">
                        <span>Damage</span>
                        <span>${tower.damage}</span>
                    </div>
                    <div class="tower-stat">
                        <span>Fire Rate</span>
                        <span>${Math.round(60/tower.fireRate)}/sec</span>
                    </div>
                `;
                
                // Update button states
                document.getElementById('rangeUpgrade').disabled = tower.rangeUpgraded || gameState.money < 50;
                document.getElementById('pierceUpgrade').disabled = tower.pierceUpgraded || gameState.money < 50;
            } else {
                infoDiv.innerHTML = `
                    <div style="text-align: center; opacity: 0.7; padding: 20px;">
                        <div style="margin-bottom: 10px;">No tower selected</div>
                        <div style="font-size: 12px;">Click on a placed tower to select it</div>
                    </div>
                `;
                document.getElementById('rangeUpgrade').disabled = true;
                document.getElementById('pierceUpgrade').disabled = true;
            }
        }

        function setSpeed(speed) {
            gameState.gameSpeed = speed;
            document.getElementById('speedSlider').value = speed;
            document.getElementById('speedDisplay').textContent = speed + 'x';
            
            // Update button states
            document.querySelectorAll('.speed-btn').forEach(btn => {
                btn.classList.remove('active');
                if (parseInt(btn.dataset.speed) === speed) {
                    btn.classList.add('active');
                }
            });
        }

        function updateSpeedFromSlider() {
            let speed = parseInt(document.getElementById('speedSlider').value);
            setSpeed(speed);
        }

        function updateUI() {
            document.getElementById('round').textContent = gameState.round;
            document.getElementById('money').textContent = gameState.money;
            document.getElementById('lives').textContent = gameState.lives;
            
            // Update button states
            document.getElementById('startBtn').disabled = gameState.gameStarted;
            document.getElementById('nextRoundBtn').disabled = gameState.waveInProgress || gameState.round === 0;
            
            updateSelectedTowerInfo();
            
            // Check for game over
            if (gameState.lives <= 0) {
                gameState.gameOver = true;
            }
        }

        function drawGameOver() {
            fill(0, 0, 0, 150);
            rect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            fill(255, 0, 0);
            textSize(48);
            textAlign(CENTER, CENTER);
            text('GAME OVER', CANVAS_WIDTH/2, CANVAS_HEIGHT/2);
            
            fill(255);
            textSize(24);
            text(`You survived ${gameState.round} rounds!`, CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 50);
        }

        function drawGameWon() {
            fill(0, 0, 0, 150);
            rect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            fill(0, 255, 0);
            textSize(48);
            textAlign(CENTER, CENTER);
            text('YOU WIN!', CANVAS_WIDTH/2, CANVAS_HEIGHT/2);
            
            fill(255);
            textSize(24);
            text('Congratulations!', CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 50);
        }

        function restartGame() {
            gameState = {
                money: 650,
                lives: 40,
                round: 0,
                maxRounds: 40,
                balloons: [],
                towers: [],
                projectiles: [],
                waveInProgress: false,
                balloonsInWave: 0,
                balloonsSpawned: 0,
                spawnTimer: 0,
                spawnInterval: 30,
                gameOver: false,
                gameWon: false,
                gameStarted: false,
                selectedTower: null,
                gameSpeed: 1,
                selectedTowerType: 'monkey'
            };
            
            baseTowerConfig = {
                range: 120,
                pierce: 1,
                damage: 1,
                fireRate: 60,
                cost: 100
            };
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('nextRoundBtn').disabled = true;
            setSpeed(1); // Reset speed to 1x
            selectTowerType('monkey'); // Reset tower selection
            updateUI();
        }
    </script>
</body>
</html> 