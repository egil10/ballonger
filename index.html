<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bloons Tower Defense MVP</title>
    <link rel="icon" type="image/svg+xml" href="logo.svg">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 10px;
            background: #2c3e50;
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: auto;
        }
        #gameContainer {
            display: flex;
            background: #34495e;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            max-width: 95vw;
            max-height: 95vh;
        }
        canvas {
            display: block;
            border-radius: 10px 0 0 10px;
        }
        #ui {
            width: 300px;
            background: #27ae60;
            padding: 20px;
            border-radius: 0 10px 10px 0;
            color: white;
            max-height: 800px;
            overflow-y: auto;
        }
        .stat {
            margin-bottom: 15px;
            font-size: 18px;
            font-weight: bold;
        }
        .upgrade-btn {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        .upgrade-btn:hover {
            background: #c0392b;
        }
        .upgrade-btn:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
        }
        .tower-info {
            margin-top: 20px;
            padding: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
        }
        .logo {
            text-align: center;
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: bold;
        }
        .game-btn {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: background 0.3s;
        }
        .game-btn:hover {
            background: #2980b9;
        }
        .game-btn:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
        }
        .speed-btn {
            flex: 1;
            padding: 8px;
            background: #95a5a6;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s;
        }
        .speed-btn:hover {
            background: #7f8c8d;
        }
        .speed-btn.active {
            background: #e74c3c;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="sketch-holder"></div>
        <div id="ui">
            <div class="logo">egil games</div>
            <div class="stat">Round: <span id="round">0</span>/20</div>
            <div class="stat">Money: $<span id="money">650</span></div>
            <div class="stat">Lives: <span id="lives">40</span></div>
            
            <button class="game-btn" id="startBtn">Start Game</button>
            <button class="game-btn" id="nextRoundBtn" disabled>Next Round</button>
            
            <h3>Build Towers</h3>
            <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                <div style="width: 40px; height: 40px; background: #8B4513; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">M</div>
                <div style="width: 40px; height: 40px; background: #FF69B4; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">I</div>
                <div style="width: 40px; height: 40px; background: #87CEEB; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">F</div>
                <div style="width: 40px; height: 40px; background: #000; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">B</div>
                <div style="width: 40px; height: 40px; background: #4169E1; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">S</div>
            </div>
            
            <h3>Upgrades</h3>
            <button class="upgrade-btn" id="rangeUpgrade">Upgrade Range ($50)</button>
            <button class="upgrade-btn" id="pierceUpgrade">Upgrade Pierce ($50)</button>
            
            <div class="tower-info">
                <h4>Selected Tower</h4>
                <div id="selectedTowerInfo">Click a tower to select</div>
            </div>
            
            <div style="margin-top: 20px;">
                <h3>Game Speed</h3>
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                    <label for="speedSlider" style="font-size: 14px;">Speed:</label>
                    <input type="range" id="speedSlider" min="1" max="10" value="1" style="flex: 1;">
                    <span id="speedDisplay" style="font-weight: bold; min-width: 30px;">1x</span>
                </div>
                <div style="display: flex; gap: 5px; margin-bottom: 20px;">
                    <button class="speed-btn" data-speed="1">1x</button>
                    <button class="speed-btn" data-speed="2">2x</button>
                    <button class="speed-btn" data-speed="5">5x</button>
                    <button class="speed-btn" data-speed="10">10x</button>
                </div>
            </div>
            
            <div style="margin-top: 20px; text-align: center;">
                <button class="upgrade-btn" id="restartBtn">Restart</button>
            </div>
        </div>
    </div>

    <script>
        // Game constants
        const GRID_SIZE = 20; // Smaller grid size to fit 40x40 on screen
        const COLS = 40;
        const ROWS = 40;
        const CANVAS_WIDTH = COLS * GRID_SIZE;
        const CANVAS_HEIGHT = ROWS * GRID_SIZE;
        const TOWER_PLACEMENT_RADIUS = 60; // Adjusted for smaller grid

        // Game state
        let gameState = {
            money: 650,
            lives: 40,
            round: 0,
            maxRounds: 20,
            balloons: [],
            towers: [],
            projectiles: [],
            waveInProgress: false,
            balloonsInWave: 0,
            balloonsSpawned: 0,
            spawnTimer: 0,
            spawnInterval: 30,
            gameOver: false,
            gameWon: false,
            gameStarted: false,
            selectedTower: null,
            gameSpeed: 1
        };

        // Base tower configuration
        let baseTowerConfig = {
            range: 120,
            pierce: 1,
            damage: 1,
            fireRate: 60
        };

        // Balloon colors by tier
        const BALLOON_COLORS = {
            1: [255, 0, 0],    // Red
            2: [0, 0, 255],    // Blue
            3: [0, 255, 0],    // Green
            4: [255, 255, 0],  // Yellow
            5: [0, 0, 0],      // Black
            6: [255, 255, 255] // White
        };

        // Expanded 40x40 path definition
        const PATH = [
            {x: 1, y: 1}, {x: 2, y: 1}, {x: 3, y: 1}, {x: 4, y: 1}, {x: 5, y: 1}, {x: 6, y: 1}, {x: 7, y: 1}, {x: 8, y: 1}, {x: 9, y: 1}, {x: 10, y: 1}, {x: 11, y: 1}, {x: 12, y: 1}, {x: 13, y: 1},
            {x: 14, y: 2}, {x: 15, y: 3}, {x: 16, y: 4}, {x: 17, y: 5}, {x: 18, y: 6}, {x: 19, y: 7}, {x: 20, y: 8}, {x: 21, y: 9}, {x: 22, y: 10}, {x: 23, y: 11}, {x: 24, y: 12},
            {x: 1, y: 13}, {x: 25, y: 13}, {x: 1, y: 14}, {x: 26, y: 14}, {x: 1, y: 15}, {x: 27, y: 15}, {x: 1, y: 16}, {x: 28, y: 16},
            {x: 2, y: 17}, {x: 29, y: 17}, {x: 3, y: 18}, {x: 30, y: 18}, {x: 4, y: 19}, {x: 31, y: 19}, {x: 5, y: 20}, {x: 32, y: 20},
            {x: 6, y: 21}, {x: 33, y: 21}, {x: 7, y: 22}, {x: 34, y: 22}, {x: 8, y: 23}, {x: 35, y: 23}, {x: 9, y: 24}, {x: 36, y: 24},
            {x: 10, y: 25}, {x: 37, y: 25}, {x: 11, y: 26}, {x: 38, y: 26}, {x: 12, y: 27}, {x: 39, y: 27}, {x: 13, y: 28}, {x: 40, y: 28},
            {x: 14, y: 29}, {x: 40, y: 29}, {x: 15, y: 30}, {x: 40, y: 30}, {x: 16, y: 31}, {x: 40, y: 31}, {x: 17, y: 32}, {x: 40, y: 32},
            {x: 18, y: 33}, {x: 40, y: 33}, {x: 19, y: 34}, {x: 40, y: 34}, {x: 20, y: 35}, {x: 39, y: 35}, {x: 21, y: 36}, {x: 38, y: 36},
            {x: 22, y: 37}, {x: 37, y: 37}, {x: 23, y: 38}, {x: 36, y: 38}, {x: 24, y: 39}, {x: 35, y: 39}, {x: 25, y: 40},
            {x: 26, y: 40}, {x: 27, y: 40}, {x: 28, y: 40}, {x: 29, y: 40}, {x: 30, y: 40}, {x: 31, y: 40}, {x: 32, y: 40}, {x: 33, y: 40}, {x: 34, y: 40}
        ];

        function setup() {
            let canvas = createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);
            canvas.parent('sketch-holder');
            
            // Set up event listeners
            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('nextRoundBtn').addEventListener('click', startNextRound);
            document.getElementById('rangeUpgrade').addEventListener('click', upgradeRange);
            document.getElementById('pierceUpgrade').addEventListener('click', upgradePierce);
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            
            // Speed control event listeners
            document.getElementById('speedSlider').addEventListener('input', updateSpeedFromSlider);
            document.querySelectorAll('.speed-btn').forEach(btn => {
                btn.addEventListener('click', () => setSpeed(parseInt(btn.dataset.speed)));
            });
            
            updateUI();
        }

        function draw() {
            if (gameState.gameOver) {
                drawGameOver();
                return;
            }
            
            if (gameState.gameWon) {
                drawGameWon();
                return;
            }
            
            drawBackground();
            drawPath();
            updateAndDrawBalloons();
            updateAndDrawTowers();
            updateAndDrawProjectiles();
            updateWave();
            updateUI();
        }

        function drawBackground() {
            // Draw grass background
            fill(34, 139, 34);
            rect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Draw grid lines
            stroke(0, 100, 0);
            strokeWeight(1);
            for (let i = 0; i <= COLS; i++) {
                line(i * GRID_SIZE, 0, i * GRID_SIZE, CANVAS_HEIGHT);
            }
            for (let j = 0; j <= ROWS; j++) {
                line(0, j * GRID_SIZE, CANVAS_WIDTH, j * GRID_SIZE);
            }
            noStroke();
        }

        function drawPath() {
            // Draw path squares
            fill(139, 69, 19);
            for (let i = 0; i < PATH.length; i++) {
                rect(PATH[i].x * GRID_SIZE, PATH[i].y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
            }
            
            // Draw start (blue) and end (red) squares
            fill(0, 0, 255);
            rect(PATH[0].x * GRID_SIZE, PATH[0].y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
            
            fill(255, 0, 0);
            rect(PATH[PATH.length - 1].x * GRID_SIZE, PATH[PATH.length - 1].y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
        }

        function startGame() {
            gameState.gameStarted = true;
            gameState.round = 1;
            document.getElementById('startBtn').disabled = true;
            startWave();
        }

        function startNextRound() {
            gameState.round++;
            document.getElementById('nextRoundBtn').disabled = true;
            startWave();
        }

        function startWave() {
            gameState.waveInProgress = true;
            
            // Progressive difficulty: more balloons and varied timing
            let baseBalloons = 8;
            let roundMultiplier = 1 + (gameState.round - 1) * 0.3;
            gameState.balloonsInWave = Math.floor(baseBalloons * roundMultiplier);
            
            // Varied spawn timing based on round
            let baseInterval = 30;
            let timingVariation = Math.max(10, baseInterval - (gameState.round - 1) * 2);
            gameState.spawnInterval = timingVariation;
            
            gameState.balloonsSpawned = 0;
            gameState.spawnTimer = 0;
        }

        function updateWave() {
            if (!gameState.waveInProgress || !gameState.gameStarted) return;
            
            gameState.spawnTimer += gameState.gameSpeed;
            
            // Spawn balloons with varied timing
            if (gameState.spawnTimer >= gameState.spawnInterval && gameState.balloonsSpawned < gameState.balloonsInWave) {
                spawnBalloon();
                gameState.balloonsSpawned++;
                gameState.spawnTimer = 0;
                
                // Add some randomness to spawn timing
                gameState.spawnInterval = Math.max(5, gameState.spawnInterval + Math.floor(Math.random() * 10) - 5);
            }
            
            // Check if wave is complete
            if (gameState.balloonsSpawned >= gameState.balloonsInWave && gameState.balloons.length === 0) {
                gameState.waveInProgress = false;
                
                if (gameState.round >= gameState.maxRounds) {
                    gameState.gameWon = true;
                } else {
                    document.getElementById('nextRoundBtn').disabled = false;
                }
            }
        }

        function spawnBalloon() {
            // Progressive difficulty: higher tier balloons appear in later rounds
            let maxTier = Math.min(6, Math.floor(gameState.round / 3) + 1);
            let tier = Math.floor(Math.random() * maxTier) + 1;
            let speed = tier === 4 ? 2 : 1; // Yellow balloons are faster
            
            // Increase speed in later rounds
            speed += Math.floor((gameState.round - 1) / 5);
            
            gameState.balloons.push({
                x: PATH[0].x * GRID_SIZE + GRID_SIZE / 2,
                y: PATH[0].y * GRID_SIZE + GRID_SIZE / 2,
                pathIndex: 0,
                tier: tier,
                speed: speed,
                health: 1,
                maxHealth: 1
            });
        }

        function updateAndDrawBalloons() {
            for (let i = gameState.balloons.length - 1; i >= 0; i--) {
                let balloon = gameState.balloons[i];
                
                // Move balloon along path
                if (balloon.pathIndex < PATH.length - 1) {
                    let targetX = PATH[balloon.pathIndex + 1].x * GRID_SIZE + GRID_SIZE / 2;
                    let targetY = PATH[balloon.pathIndex + 1].y * GRID_SIZE + GRID_SIZE / 2;
                    
                    let dx = targetX - balloon.x;
                    let dy = targetY - balloon.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < balloon.speed * gameState.gameSpeed) {
                        balloon.pathIndex++;
                        if (balloon.pathIndex >= PATH.length - 1) {
                            // Balloon reached the end
                            gameState.lives--;
                            gameState.balloons.splice(i, 1);
                            continue;
                        }
                    } else {
                        balloon.x += (dx / distance) * balloon.speed * gameState.gameSpeed;
                        balloon.y += (dy / distance) * balloon.speed * gameState.gameSpeed;
                    }
                }
                
                // Draw balloon
                let color = BALLOON_COLORS[balloon.tier];
                fill(color[0], color[1], color[2]);
                ellipse(balloon.x, balloon.y, GRID_SIZE * 0.8, GRID_SIZE * 0.8);
                
                // Draw health bar for damaged balloons
                if (balloon.health < balloon.maxHealth) {
                    fill(255, 0, 0);
                    rect(balloon.x - GRID_SIZE/2, balloon.y - GRID_SIZE/2 - 10, GRID_SIZE, 5);
                    fill(0, 255, 0);
                    rect(balloon.x - GRID_SIZE/2, balloon.y - GRID_SIZE/2 - 10, 
                         (balloon.health / balloon.maxHealth) * GRID_SIZE, 5);
                }
            }
        }

        function updateAndDrawTowers() {
            for (let tower of gameState.towers) {
                // Draw tower
                if (gameState.selectedTower === tower) {
                    fill(255, 215, 0); // Gold for selected tower
                } else {
                    fill(139, 69, 19);
                }
                rect(tower.x - GRID_SIZE/2, tower.y - GRID_SIZE/2, GRID_SIZE, GRID_SIZE);
                
                // Draw range indicator (transparent)
                fill(255, 255, 255, 30);
                ellipse(tower.x, tower.y, tower.range * 2, tower.range * 2);
                
                // Update cooldown
                if (tower.cooldown > 0) {
                    tower.cooldown -= gameState.gameSpeed;
                }
                
                // Find target and shoot
                if (tower.cooldown <= 0) {
                    let target = findTarget(tower);
                    if (target) {
                        shoot(tower, target);
                        tower.cooldown = tower.fireRate;
                    }
                }
            }
        }

        function findTarget(tower) {
            let bestTarget = null;
            let bestProgress = -1;
            
            for (let balloon of gameState.balloons) {
                let distance = dist(tower.x, tower.y, balloon.x, balloon.y);
                if (distance <= tower.range) {
                    if (balloon.pathIndex > bestProgress) {
                        bestTarget = balloon;
                        bestProgress = balloon.pathIndex;
                    }
                }
            }
            
            return bestTarget;
        }

        function shoot(tower, target) {
            gameState.projectiles.push({
                x: tower.x,
                y: tower.y,
                targetX: target.x,
                targetY: target.y,
                speed: 5,
                damage: tower.damage,
                pierce: tower.pierce,
                targetsHit: []
            });
        }

        function updateAndDrawProjectiles() {
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                let projectile = gameState.projectiles[i];
                
                // Move projectile
                let dx = projectile.targetX - projectile.x;
                let dy = projectile.targetY - projectile.y;
                let distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < projectile.speed * gameState.gameSpeed) {
                    // Projectile reached target
                    gameState.projectiles.splice(i, 1);
                    continue;
                }
                
                projectile.x += (dx / distance) * projectile.speed * gameState.gameSpeed;
                projectile.y += (dy / distance) * projectile.speed * gameState.gameSpeed;
                
                // Draw projectile
                fill(255, 255, 0);
                ellipse(projectile.x, projectile.y, 8, 8);
                
                // Check for hits
                for (let j = gameState.balloons.length - 1; j >= 0; j--) {
                    let balloon = gameState.balloons[j];
                    
                    if (projectile.targetsHit.includes(balloon)) continue;
                    
                    let hitDistance = dist(projectile.x, projectile.y, balloon.x, balloon.y);
                    if (hitDistance < GRID_SIZE / 2) {
                        balloon.health -= projectile.damage;
                        projectile.targetsHit.push(balloon);
                        
                        if (balloon.health <= 0) {
                            // Balloon popped
                            gameState.money += 5;
                            gameState.balloons.splice(j, 1);
                            
                            // Create child balloons based on tier
                            if (balloon.tier > 1) {
                                let childTier = balloon.tier - 1;
                                let childSpeed = childTier === 4 ? 2 : 1;
                                let childCount = balloon.tier === 5 ? 2 : 1; // Black balloons create 2 children
                                
                                for (let k = 0; k < childCount; k++) {
                                    gameState.balloons.push({
                                        x: balloon.x,
                                        y: balloon.y,
                                        pathIndex: balloon.pathIndex,
                                        tier: childTier,
                                        speed: childSpeed,
                                        health: 1,
                                        maxHealth: 1
                                    });
                                }
                            }
                        }
                        
                        if (projectile.targetsHit.length >= projectile.pierce) {
                            gameState.projectiles.splice(i, 1);
                            break;
                        }
                    }
                }
            }
        }

        function mousePressed() {
            if (mouseX < CANVAS_WIDTH && mouseY < CANVAS_HEIGHT) {
                // Check if clicking on existing tower to select it
                for (let tower of gameState.towers) {
                    let distance = dist(mouseX, mouseY, tower.x, tower.y);
                    if (distance < GRID_SIZE / 2) {
                        gameState.selectedTower = tower;
                        updateSelectedTowerInfo();
                        return;
                    }
                }
                
                // Place new tower at grid position
                let gridX = Math.floor(mouseX / GRID_SIZE);
                let gridY = Math.floor(mouseY / GRID_SIZE);
                
                // Check if position is valid (not on path)
                let onPath = false;
                for (let pathPoint of PATH) {
                    if (pathPoint.x === gridX && pathPoint.y === gridY) {
                        onPath = true;
                        break;
                    }
                }
                
                if (!onPath) {
                    let towerX = gridX * GRID_SIZE + GRID_SIZE / 2;
                    let towerY = gridY * GRID_SIZE + GRID_SIZE / 2;
                    
                    // Check minimum distance from other towers
                    let tooClose = false;
                    for (let tower of gameState.towers) {
                        let distance = dist(towerX, towerY, tower.x, tower.y);
                        if (distance < TOWER_PLACEMENT_RADIUS) {
                            tooClose = true;
                            break;
                        }
                    }
                    
                    if (!tooClose) {
                        let newTower = {
                            x: towerX,
                            y: towerY,
                            range: baseTowerConfig.range,
                            pierce: baseTowerConfig.pierce,
                            damage: baseTowerConfig.damage,
                            fireRate: baseTowerConfig.fireRate,
                            cooldown: 0,
                            rangeUpgraded: false,
                            pierceUpgraded: false
                        };
                        
                        gameState.towers.push(newTower);
                        gameState.selectedTower = newTower;
                        updateSelectedTowerInfo();
                    }
                }
            }
        }

        function upgradeRange() {
            if (gameState.selectedTower && !gameState.selectedTower.rangeUpgraded && gameState.money >= 50) {
                gameState.money -= 50;
                gameState.selectedTower.range += 20;
                gameState.selectedTower.rangeUpgraded = true;
                updateSelectedTowerInfo();
            }
        }

        function upgradePierce() {
            if (gameState.selectedTower && !gameState.selectedTower.pierceUpgraded && gameState.money >= 50) {
                gameState.money -= 50;
                gameState.selectedTower.pierce += 1;
                gameState.selectedTower.pierceUpgraded = true;
                updateSelectedTowerInfo();
            }
        }

        function updateSelectedTowerInfo() {
            let infoDiv = document.getElementById('selectedTowerInfo');
            if (gameState.selectedTower) {
                let tower = gameState.selectedTower;
                infoDiv.innerHTML = `
                    <div>Range: ${tower.range} ${tower.rangeUpgraded ? '(Upgraded)' : ''}</div>
                    <div>Pierce: ${tower.pierce} ${tower.pierceUpgraded ? '(Upgraded)' : ''}</div>
                    <div>Damage: ${tower.damage}</div>
                `;
                
                // Update button states
                document.getElementById('rangeUpgrade').disabled = tower.rangeUpgraded || gameState.money < 50;
                document.getElementById('pierceUpgrade').disabled = tower.pierceUpgraded || gameState.money < 50;
            } else {
                infoDiv.innerHTML = 'Click a tower to select';
                document.getElementById('rangeUpgrade').disabled = true;
                document.getElementById('pierceUpgrade').disabled = true;
            }
        }

        function setSpeed(speed) {
            gameState.gameSpeed = speed;
            document.getElementById('speedSlider').value = speed;
            document.getElementById('speedDisplay').textContent = speed + 'x';
            
            // Update button states
            document.querySelectorAll('.speed-btn').forEach(btn => {
                btn.classList.remove('active');
                if (parseInt(btn.dataset.speed) === speed) {
                    btn.classList.add('active');
                }
            });
        }

        function updateSpeedFromSlider() {
            let speed = parseInt(document.getElementById('speedSlider').value);
            setSpeed(speed);
        }

        function updateUI() {
            document.getElementById('round').textContent = gameState.round;
            document.getElementById('money').textContent = gameState.money;
            document.getElementById('lives').textContent = gameState.lives;
            
            // Update button states
            document.getElementById('startBtn').disabled = gameState.gameStarted;
            document.getElementById('nextRoundBtn').disabled = gameState.waveInProgress || gameState.round === 0;
            
            updateSelectedTowerInfo();
            
            // Check for game over
            if (gameState.lives <= 0) {
                gameState.gameOver = true;
            }
        }

        function drawGameOver() {
            fill(0, 0, 0, 150);
            rect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            fill(255, 0, 0);
            textSize(48);
            textAlign(CENTER, CENTER);
            text('GAME OVER', CANVAS_WIDTH/2, CANVAS_HEIGHT/2);
            
            fill(255);
            textSize(24);
            text(`You survived ${gameState.round} rounds!`, CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 50);
        }

        function drawGameWon() {
            fill(0, 0, 0, 150);
            rect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            fill(0, 255, 0);
            textSize(48);
            textAlign(CENTER, CENTER);
            text('YOU WIN!', CANVAS_WIDTH/2, CANVAS_HEIGHT/2);
            
            fill(255);
            textSize(24);
            text('Congratulations!', CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 50);
        }

        function restartGame() {
            gameState = {
                money: 650,
                lives: 40,
                round: 0,
                maxRounds: 20,
                balloons: [],
                towers: [],
                projectiles: [],
                waveInProgress: false,
                balloonsInWave: 0,
                balloonsSpawned: 0,
                spawnTimer: 0,
                spawnInterval: 30,
                gameOver: false,
                gameWon: false,
                gameStarted: false,
                selectedTower: null,
                gameSpeed: 1
            };
            
            baseTowerConfig = {
                range: 120,
                pierce: 1,
                damage: 1,
                fireRate: 60
            };
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('nextRoundBtn').disabled = true;
            setSpeed(1); // Reset speed to 1x
            updateUI();
        }
    </script>
</body>
</html> 